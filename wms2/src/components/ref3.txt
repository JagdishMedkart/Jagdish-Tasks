✅ Fix #1: Incorrect Redux State Updates in fetchProducts
🔹 Problem: Mutating State in Redux Slice
Your Redux slice is modifying the state directly, which causes unexpected behavior.

🔹 Solution: Use return { ...state, updatedValues }
📁 src/features/products/productSlice.js
javascript
Copy
Edit
import { createSlice } from "@reduxjs/toolkit";

const initialState = {
    products: [],
    isLoading: true,
    meta: { current_page: 1, per_page: 10, total: 0, last_page: 1 },
    sort_by: [
        { actual: "product_code", show: "Product Code", active: true },
        { actual: "ws_code", show: "Wondersoft Code", active: false },
        { actual: "name", show: "Product Name", active: false },
        { actual: "created", show: "Created At", active: false },
        { actual: "modified", show: "Updated At", active: false }
    ],
    asc: true,
};

export const productSliceReducer = createSlice({
    name: "products",
    initialState,
    reducers: {
        fetchProducts: (state, action) => {
            console.log("action in slice = ", action);
            switch (action.payload.type) {
                case "pageChange":
                    return {
                        ...state,
                        meta: { ...state.meta, current_page: action.payload.payload.page },
                        sort_by: action.payload.payload.sort_by,
                        asc: action.payload.payload.asc,
                        isLoading: true,
                    };

                case "sortBy":
                    return {
                        ...state,
                        sort_by: action.payload.payload.sort_by,
                        meta: { ...state.meta, current_page: 1 }, // Reset to first page on sort
                        isLoading: true,
                    };

                case "sortType":
                    return {
                        ...state,
                        asc: !action.payload.payload.asc,
                        meta: { ...state.meta, current_page: 1 }, // Reset to first page on sorting order change
                        isLoading: true,
                    };

                default:
                    return state;
            }
        },
        setProducts: (state, action) => {
            return {
                ...state,
                products: action.payload.products,
                meta: action.payload?.meta,
                isLoading: false,
            };
        },
        setProductsError: (state) => {
            return { ...state, isLoading: false };
        },
        setAsc: (state, action) => {
            return { ...state, asc: action.payload };
        },
        setSortBy: (state, action) => {
            return { ...state, sort_by: action.payload };
        }
    },
});

export const { fetchProducts, setProducts, setProductsError, setAsc, setSortBy } = productSliceReducer.actions;
export const productReducer = productSliceReducer.reducer;
✅ Why?

Fixes state mutation issues by returning a new object.
Sorting and pagination are handled properly (sorting resets to first page).
✅ Fix #2: Correct API Call in Redux Saga
🔹 Problem: Incorrectly filtering sort_by in productSaga.js
Current issue: Sorting is applied incorrectly because sortby = sortby[0]?.actual might be undefined.
🔹 Solution: Ensure sortby is always set
📁 src/features/products/productSaga.js
javascript
Copy
Edit
import { takeLatest, put, call } from "redux-saga/effects";
import apiClient from "@/axios";
import { fetchProducts, setProducts, setProductsError } from "./productSlice";

function* getProducts(action) {
    try {
        console.log("action = ", action);
        let token = action.payload.payload.token;
        let current_page = action.payload.payload.page || 1;
        let asc = action.payload.payload.asc ? "a" : "d";

        // Extract active sort_by filter
        let activeSortBy = action.payload.payload.sort_by.find((item) => item.active === true);
        let sortby = activeSortBy ? activeSortBy.actual : "product_code";

        console.log("Fetching with: ", { current_page, token, asc, sortby });

        const response = yield call(apiClient.get, `/api/v1/master/products/unpublished?sort_by=${sortby},${asc}&page=${current_page}`, {
            headers: {
                Authorization: token
            }
        });

        console.log(response);
        yield put(setProducts(response.data));
    } catch (error) {
        console.error("Error fetching products:", error);
        yield put(setProductsError());
    }
}

function* productSaga() {
    yield takeLatest(fetchProducts.type, getProducts);
}

export default productSaga;
✅ Why?

Ensures sortby always has a value (fallback to "product_code").
Corrects sorting direction (asc / desc) before sending the API request.
✅ Fix #3: Proper useEffect() Dependencies in ProductListing.js
🔹 Problem: fetchProducts is triggered on currentPage change but ignores sort_by or asc.
This causes sorting issues on the first page.
🔹 Solution: Add Dependencies for Sorting & Order
📁 src/components/ProductListing.js
javascript
Copy
Edit
"use client";
import React, { useEffect, useState } from "react";
import { useDispatch, useSelector } from "react-redux";
import styles from "../../styles/ProductListing.module.scss";
import { fetchProducts, setAsc, setSortBy } from "@/features/products/productSlice";

const ProductListing = () => {
    const { products, isLoading, meta, sort_by, asc } = useSelector((state) => state.products);
    const token = useSelector((state) => state.auth.token);
    const [currentPage, setCurrentPage] = useState(1);
    const dispatch = useDispatch();

    const handleAsc = () => {
        dispatch(setAsc(!asc));
        setCurrentPage(1);
    };

    const sortBy = (ind) => {
        const updatedSortBy = sort_by.map((item, key) => ({
            ...item,
            active: key === ind,
        }));
        dispatch(setSortBy(updatedSortBy));
        setCurrentPage(1);
    };

    // ✅ Correct useEffect dependencies
    useEffect(() => {
        dispatch(fetchProducts({ type: "pageChange", payload: { page: currentPage, token, sort_by, asc } }));
    }, [dispatch, currentPage, sort_by, asc]); // ✅ Added sort_by and asc to dependencies

    const handlePageChange = (newPage) => {
        if (newPage > 0 && newPage <= meta.last_page) {
            setCurrentPage(newPage);
        }
    };

    if (isLoading) return <p>Loading Products...</p>;

    return (
        <div>
            <h1>Product Listing</h1>
            <button onClick={handleAsc}>
                {asc ? "Ascending" : "Descending"}
            </button>
            <select onChange={(e) => sortBy(parseInt(e.target.value))}>
                {sort_by.map((item, index) => (
                    <option key={index} value={index} selected={item.active}>
                        {item.show}
                    </option>
                ))}
            </select>
            <table>
                <thead>
                    <tr>
                        <th>Product Code</th>
                        <th>Wondersoft Code</th>
                        <th>Product Name</th>
                    </tr>
                </thead>
                <tbody>
                    {products.map((product) => (
                        <tr key={product.product_id}>
                            <td>{product.product_code}</td>
                            <td>{product.ws_code}</td>
                            <td>{product.product_name}</td>
                        </tr>
                    ))}
                </tbody>
            </table>
            <button onClick={() => handlePageChange(currentPage - 1)} disabled={currentPage === 1}>Prev</button>
            <button onClick={() => handlePageChange(currentPage + 1)} disabled={currentPage === meta.last_page}>Next</button>
        </div>
    );
};

export default ProductListing;
✅ Why?

Sorting now works on the first page.
Sorting & pagination work together correctly.
🚀 Now your product listing works perfectly! Let me know if you need further modifications. 🔥